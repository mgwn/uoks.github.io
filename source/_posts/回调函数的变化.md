title: 回调函数的变化
date: 2014/10/1 11:00:00
tags: 
- cocos2d-x
---

cocos2d-x 3.0开始使用C++11中的std::function，std::bind和lambda表达式处理回调
## MenuItem

	//...
	auto closeItem = MenuItemImage::create(
                                           "CloseNormal.png",
                                           "CloseSelected.png",
                                           CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));
   	//...
    
   	void HelloWorld::menuCloseCallback(Object* pSender)
	{
 	   Director::getInstance()->end();
 
	#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
  	  exit(0);
	#endif
	}
	
	
### CC_CALLBACK_x
注意到在3.0版本中使用到 CC_CALLBACK_1 这样一个宏定义。

	// new callbacks based on C++11
	#define CC_CALLBACK_0(__selector__,__target__, ...) std::bind(&__selector__,__target__, ##__VA_ARGS__)
	#define CC_CALLBACK_1(__selector__,__target__, ...) std::bind(&__selector__,__target__, std::placeholders::_1, ##__VA_ARGS__)
	#define CC_CALCC_CALLBACK_1(HelloWorld::menuCloseCallback,this)LBACK_2(__selector__,__target__, ...) std::bind(&__selector__,__target__, std::placeholders::_1, std::placeholders::_2, ##__VA_ARGS__)
	#define CC_CALLBACK_3(__selector__,__target__, ...) std::bind(&__selector__,__target__, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3 ##__VA_ARGS__)
	
原来 CC_CALLBACK_ 的宏定义中后面的 0 1 2 3分别表示的是 不事先指定回调函数参数的个数。

例如说 CC_CALLBACK_ 1 表示的是，回调函数中不事先指定参数是一个，而事先指定的回调函数的参数 可以任意多个。

而且要注意到其中 不指定回调函数参数 和 指定回调函数参数 的顺序，注意不事先指定的在前，事先指定的在后。

### function

	std::function<void(object*)> func = std::bind(&HelloWorld::menuCloseCallback,this, std::placeholders::_1,1,2);
    auto closeItem = MenuItemImage::create(
                                           "CloseNormal.png",
                                           "CloseSelected.png",
                                           func);

### 使用lambda表达式

	auto closeItem = MenuItemImage::create(
                                           "CloseNormal.png",
                                           "CloseSelected.png",
                                           [&](Object *sender){
                                               Director::getInstance()->end();
                                               #if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
                                               exit(0);
                                               #endif
                                           });
## CallFunc、CallFuncN
2.x|3.x
--|--
CCCalFunc|std::function
CCCalFuncN|std::function
CCCalFuncND and CCCallFuncO|CallFuncN and CallFunc

### CallFunc

	static CallFunc * create(const std::function<void()>& func);

例子

	// in v2.1
	CCCallFunc *action1 = CCCallFunc::create( this, callfunc_selector( MyClass::callback_0 ) );
 
	// in v3.0 (short version)
	auto action1 = CallFunc::create( CC_CALLBACK_0(MyClass::callback_0,this));
	auto action2 = CallFunc::create( CC_CALLBACK_0(MyClass::callback_1,this, 	additional_parameters));
 
	// in v3.0 (long version)
	auto action1 = CallFunc::create( std::bind( &MyClass::callback_0, this));
	auto action2 = CallFunc::create( std::bind( &MyClass::callback_1, this, 	additional_parameters));
 
	// in v3.0 you can also use lambdas or any other "Function" object
	auto action1 = CallFunc::create(
                 [&](){
                     auto s = Director::sharedDirector()->getWinSize();
                     auto label = LabelTTF::create("called:lambda callback", "Marker Felt", 16);
                     label->setPosition(ccp( s.width/4*1,s.height/2-40));
                     this->addChild(label);
                 }  );

### CallFuncN

	static CallFuncN * create(const std::function<void(node*)>& func);

注意回调动作带一个Node*参数
假设回调函数

	void ActionCallFuncN::callback(Node* sender )

用法

	auto action = Sequence::create(
       MoveBy::create(2.0f, Point(150,0)),
       CallFuncN::create( CC_CALLBACK_1(ActionCallFuncN::callback, this)),
       NULL);	
       
    auto action = Sequence::create(
                                   MoveBy::create(2.0f, Point(150,0)),
          CallFuncN::create(std::bind(&ActionCallFuncN::callback,this,std::placeholders::_1)),
                                   NULL);
    auto action = Sequence::create(
                                   MoveBy::create(2.0f, Point(150,0)),
                                   CallFuncN::create([&](Node* sender){
                                    //回调动作代码
         
                                    }),
                                   NULL);

受益于C++11的新语法特性 std::bind ； CallFuncND 和 CallFuncO 都可以通过 CallFunc 和 CallFuncN 进行实现

### CallFuncND ：回调动作中带有一个Node*参数和一个void*参数

实现过程类似于 CallFuncN
假设回调函数是 ：

	void ActionCallFuncND::doRemoveFromParentAndCleanup(Node* sender, bool cleanup)

那么在回调动作中：

	CallFuncN::create( CC_CALLBACK_1(ActionCallFuncND::doRemoveFromParentAndCleanup, this, true))

这样就实现了等价于 CallFuncND 的回调动作。


### CallFuncO ：回调动作中带有一个Object*参数
实现过程类似于 CallFunc

假设回调函数是： 

	void ActionCallFuncO::callback(Node* node, bool cleanup)

那么在回调动作中：

	CallFunc::create( CC_CALLBACK_0(ActionCallFuncO::callback, this, _grossini, true)

这样就实现了等价于 CallFuncO 的回调动作。


## 总结

在新版的回调处理中，采用了C++11中的 std::function 、std::bind 、lambda 表达式，使得回调的处理变得形式多样，代码灵活了，而其中的lambda表达式可以极大的简化回调代码，推荐使用。