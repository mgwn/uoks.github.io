title: 触摸机制
date: 2014/10/1 10:00:00
tags: 
- cocos2d-x
---

在cocos2d-x 3.0中废弃了2.x的写法  
## 单点触摸简单用法
在Layer中添加如下代码，重写`onTouchXXX`函数  

	auto dispatcher = Director::getInstance()->getEventDispatcher();
	auto listener = EventListenerToucherOneByOne::create();
	listener->onTouchBegan = CC_CALLBACK_2(GameLayer::onTouchBegan,this);  
	listener->onTouchMoved = CC_CALLBACK_2(GameLayer::onTouchMoved,this);  
	listener->onTouchEnded = CC_CALLBACK_2(GameLayer::onTouchEnded,this);  
	listener->setSwallowTouches(true);//不向下传递触摸  
	dispatcher->addEventListenerWithSceneGraphPriority(listener,this);
	
`listener->setSwallowTouches(true)`，不向下触摸，简单点来说，比如有两个sprite ,A 和 B，A在上B在下（位置重叠），触摸A的时候，B不会受到影响；  
`listener->setSwallowTouches(false)`反之，向下传递触摸，触摸A也等于触摸了B；
## 多点触摸点简单用法（多Layer获取屏幕事件）

	auto dispatcher = Director::getInstance()->getEventDispatcher();  
	auto listener1 = EventListenerTouchAllAtOnce::create();  
	listener1->onTouchesBegan = CC_CALLBACK_2(GameLayer::onTouchesBegan,this);  
	listener1->onTouchesMoved = CC_CALLBACK_2(GameLayer::onTouchesMoved,this);  
	listener1->onTouchesEnded = CC_CALLBACK_2(GameLayer::onTouchesEnded,this);  
	dispatcher->addEventListenerWithSceneGraphPriority(listener1,this);
或者`setTouchEnabled(true)`，然后重写layer的`onTouchsxxx`函数

## 关于eventDispatcher
### 获取方法
	auto dispatcher = Director::getInstance()->getEventDispatcher();
事件监听器包含以下几种：

* 触摸事件（EventListenerTouch）
* 键盘响应事件（EventListenerKeyboard）
* 加速记录事件（EventListenerAcceleration）
* 鼠标响应事件(EventListenerMouse)
* 自定义事件 (EventListenrCustom)

以上事件监听器统一由`_eventDispatcher`来进行管理。

### 优先权
1. 优先级越低，越先响应事件
2. 如果优先级相同，则上册的（z轴）先接收触摸事件

有两种方法将事件监听器`listener`添加到事件调度器`_eventDispatcher`中：

	void EventDispatcher::addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node)  
	void EventDispatcher::addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority)
	
代码展开一下：

	void EventDispatcher::addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node)  
	{  
    	CCASSERT(listener && node, "Invalid parameters.");  
    	CCASSERT(!listener->isRegistered(), "The listener has been registered.");  
     	  
    	if (!listener->checkAvailable())  
       		return;  
       
    	listener->setSceneGraphPriority(node);  
    	listener->setFixedPriority(0);  
    	listener->setRegistered(true);  
    	   
    	addEventListener(listener);  
	}


	void EventDispatcher::addEventListenerWithFixedPriority(EventListener* listener, int fixedPriority)  
	{  
    	CCASSERT(listener, "Invalid parameters.");  
    	CCASSERT(!listener->isRegistered(), "The listener has been registered.");  
    	CCASSERT(fixedPriority != 0, "0 priority is forbidden for fixed priority since it's used for scene graph based priority.");  
       	
    	if (!listener->checkAvailable())  
        	return;  
       
    	listener->setSceneGraphPriority(nullptr);  
    	listener->setFixedPriority(fixedPriority);  
    	listener->setRegistered(true);  
    	listener->setPaused(false);  
    	addEventListener(listener);  
	}


* `addEventListenerWithSceneGraphPriority` 的事件监听器优先级是`0`，而且在 `addEventListenerWithFixedPriority` 中的事件监听器的优先级`不可以`设置为 `0`，因为这个是保留给 SceneGraphPriority 使用的。
* 另外，有一点非常重要，`FixedPriority` listener添加完之后需要`手动remove`，而`SceneGraphPriority` listener是跟`node`绑定的，在`node`的析构函数中会被移除。

### 移除方法：

	dispatcher->removeEventListener(listener);

## 使用Lambda
	//1加入用户触摸事件侦听
 
    auto listener=EventListenerTouchOneByOne::create();
 
    listener->setSwallowTouches(true);
 
    listener->onTouchBegan=[&](Touch * t,Event * e){
 
        //some code
 
        return true;
 
    }; //这条语句像不像Java中的匿名接口对象，像不像Objective-C中Block ，他有个很华丽的名字 lambda,读音为：腊母达，相信未来你会喜欢上这妹子的
 
	//3注册这个侦听到消息分发器中   
 
	_eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);